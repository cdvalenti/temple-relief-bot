   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  88               	.global	__floatunsisf
  89               	.global	__mulsf3
  90               	.global	__addsf3
  91               	.global	__fixunssfsi
  92               		.section	.rodata.str1.1,"aMS",@progbits,1
  93               	.LC0:
  94 0000 2564 00   		.string	"%d"
  95               	.LC1:
  96 0003 0D0A 00   		.string	"\r\n"
  97               		.section	.text.startup,"ax",@progbits
  99               	.global	main
 101               	main:
 102               		.stabd	46,0,0
   1:main.c        **** #define MCU 'atmega328'
   2:main.c        **** #define F_CPU 1000000UL
   3:main.c        **** 
   4:main.c        **** #include <avr/io.h>
   5:main.c        **** #include <avr/interrupt.h>
   6:main.c        **** #include <util/delay.h>
   7:main.c        **** #include "include/easy_atmega328p.h"
   8:main.c        **** #include "include/USART.h"
   9:main.c        **** #include "include/pinDefines.h"
  10:main.c        **** #include <stdio.h>
  11:main.c        **** #include <stdlib.h>
  12:main.c        **** 
  13:main.c        **** static inline void initADC0(void) {
  14:main.c        ****   ADMUX |= (1 << REFS0);                // reference voltage on AVCC
  15:main.c        ****   ADCSRA |= (1 << ADPS2);               // ADC clock prescaler /16
  16:main.c        ****   ADCSRA |= (1 << ADEN);                // enable ADC
  17:main.c        **** }
  18:main.c        **** 
  19:main.c        **** static inline void initTimer1Servo(void) {
  20:main.c        ****                    /* Set up Timer1 (16bit) to give a pulse every 20ms */
  21:main.c        ****                              /* Use Fast PWM mode, counter max in ICR1 */
  22:main.c        ****   TCCR1A |= (1 << WGM11);
  23:main.c        ****   TCCR1B |= (1 << WGM12) | (1 << WGM13);
  24:main.c        ****   TCCR1B |= (1 << CS10);  /* /1 prescaling -- counting in microseconds */
  25:main.c        ****   ICR1 = 50000;                                    /* TOP value = 20ms */
  26:main.c        ****   TCCR1A |= (1 << COM1A1);              /* Direct output on PB1 / OC1A */
  27:main.c        ****   DDRB |= (1 << PB1);                            /* set pin for output */
  28:main.c        **** }
  29:main.c        **** 
  30:main.c        **** int main(void)
  31:main.c        **** {
 104               	.LM0:
 105               	.LFBB1:
 106 0000 CF93      		push r28
 107 0002 DF93      		push r29
 108 0004 CDB7      		in r28,__SP_L__
 109 0006 DEB7      		in r29,__SP_H__
 110 0008 CB5D      		subi r28,-37
 111 000a D109      		sbc r29,__zero_reg__
 112 000c 0FB6      		in __tmp_reg__,__SREG__
 113 000e F894      		cli
 114 0010 DEBF      		out __SP_H__,r29
 115 0012 0FBE      		out __SREG__,__tmp_reg__
 116 0014 CDBF      		out __SP_L__,r28
 117               	/* prologue: function */
 118               	/* frame size = 219 */
 119               	/* stack size = 221 */
 120               	.L__stack_usage = 221
  32:main.c        ****   //init USART serial connection
  33:main.c        ****   
  34:main.c        ****   initUSART();
 122               	.LM1:
 123 0016 0E94 0000 		call initUSART
 124               	.LBB7:
 125               	.LBB8:
  14:main.c        ****   ADMUX |= (1 << REFS0);                // reference voltage on AVCC
 127               	.LM2:
 128 001a 8091 7C00 		lds r24,124
 129 001e 8064      		ori r24,lo8(64)
 130 0020 8093 7C00 		sts 124,r24
  15:main.c        ****   ADCSRA |= (1 << ADPS2);               // ADC clock prescaler /16
 132               	.LM3:
 133 0024 8091 7A00 		lds r24,122
 134 0028 8460      		ori r24,lo8(4)
 135 002a 8093 7A00 		sts 122,r24
  16:main.c        ****   ADCSRA |= (1 << ADEN);                // enable ADC
 137               	.LM4:
 138 002e 8091 7A00 		lds r24,122
 139 0032 8068      		ori r24,lo8(-128)
 140 0034 8093 7A00 		sts 122,r24
 141 0038 EE24      		clr r14
 142 003a E394      		inc r14
 143 003c F12C      		mov r15,__zero_reg__
 144 003e EC0E      		add r14,r28
 145 0040 FD1E      		adc r15,r29
  30:main.c        **** int main(void)
 147               	.LM5:
 148 0042 5E01      		movw r10,r28
 149 0044 89EC      		ldi r24,-55
 150 0046 A80E      		add r10,r24
 151 0048 B11C      		adc r11,__zero_reg__
 152               	.LBE8:
 153               	.LBE7:
 154 004a F701      		movw r30,r14
  35:main.c        ****   /*
  36:main.c        ****   _delay_ms(2000);
  37:main.c        ****   printString("Press Enter to continue\r\n");
  38:main.c        ****   char null_string[32];
  39:main.c        ****   readString(null_string, 32);
  40:main.c        ****   */
  41:main.c        ****   uint8_t i;
  42:main.c        ****   uint32_t sum;
  43:main.c        ****   
  44:main.c        ****   //init ADC
  45:main.c        ****   initADC0();
  46:main.c        ****   uint16_t adcValue;
  47:main.c        ****   
  48:main.c        ****   //moving average variables
  49:main.c        ****   uint8_t values = 100;
  50:main.c        ****   uint16_t pulseValue [values];
  51:main.c        ****   
  52:main.c        ****   for(i=0;i<values;i++){
  53:main.c        **** 	  pulseValue[i] = 1500;
 156               	.LM6:
 157 004c 8CED      		ldi r24,lo8(-36)
 158 004e 95E0      		ldi r25,lo8(5)
 159               	.L2:
 161               	.LM7:
 162 0050 8193      		st Z+,r24
 163 0052 9193      		st Z+,r25
  52:main.c        ****   for(i=0;i<values;i++){
 165               	.LM8:
 166 0054 EA15      		cp r30,r10
 167 0056 FB05      		cpc r31,r11
 168 0058 01F4      		brne .L2
  54:main.c        ****   }
  55:main.c        ****   
  56:main.c        ****   uint16_t avgPulseValue;
  57:main.c        ****   
  58:main.c        ****   float converter;
  59:main.c        ****   //initPWM
  60:main.c        ****   OCR1A = 1500;           /* set it to middle position initially */
 170               	.LM9:
 171 005a 8CED      		ldi r24,lo8(-36)
 172 005c 95E0      		ldi r25,lo8(5)
 173 005e 9093 8900 		sts 136+1,r25
 174 0062 8093 8800 		sts 136,r24
 175               	.LBB9:
 176               	.LBB10:
  22:main.c        ****   TCCR1A |= (1 << WGM11);
 178               	.LM10:
 179 0066 8091 8000 		lds r24,128
 180 006a 8260      		ori r24,lo8(2)
 181 006c 8093 8000 		sts 128,r24
  23:main.c        ****   TCCR1B |= (1 << WGM12) | (1 << WGM13);
 183               	.LM11:
 184 0070 8091 8100 		lds r24,129
 185 0074 8861      		ori r24,lo8(24)
 186 0076 8093 8100 		sts 129,r24
  24:main.c        ****   TCCR1B |= (1 << CS10);  /* /1 prescaling -- counting in microseconds */
 188               	.LM12:
 189 007a 8091 8100 		lds r24,129
 190 007e 8160      		ori r24,lo8(1)
 191 0080 8093 8100 		sts 129,r24
  25:main.c        ****   ICR1 = 50000;                                    /* TOP value = 20ms */
 193               	.LM13:
 194 0084 80E5      		ldi r24,lo8(80)
 195 0086 93EC      		ldi r25,lo8(-61)
 196 0088 9093 8700 		sts 134+1,r25
 197 008c 8093 8600 		sts 134,r24
  26:main.c        ****   TCCR1A |= (1 << COM1A1);              /* Direct output on PB1 / OC1A */
 199               	.LM14:
 200 0090 8091 8000 		lds r24,128
 201 0094 8068      		ori r24,lo8(-128)
 202 0096 8093 8000 		sts 128,r24
  27:main.c        ****   DDRB |= (1 << PB1);                            /* set pin for output */
 204               	.LM15:
 205 009a 219A      		sbi 0x4,1
 206               	.LBE10:
 207               	.LBE9:
 208               	.LBB11:
  61:main.c        ****   initTimer1Servo();
  62:main.c        **** 	
  63:main.c        ****   
  64:main.c        ****   
  65:main.c        ****   while(1) { 
  66:main.c        ****     
  67:main.c        ****     ADCSRA |= (1 << ADSC);                     // start ADC conversion
  68:main.c        ****     loop_until_bit_is_clear(ADCSRA, ADSC);     // wait until done
  69:main.c        ****     
  70:main.c        ****     adcValue = ADC;
  71:main.c        ****     converter = adcValue*1.955;
  72:main.c        ****     
  73:main.c        ****     for(i=values-1;i>0;i--){
  74:main.c        **** 		pulseValue[i] = pulseValue[i-1];
  75:main.c        **** 	}
  76:main.c        **** 	pulseValue[0] = converter + 500;
  77:main.c        ****     
  78:main.c        ****     sum = 0;
  79:main.c        ****     for(i=0;i<values;i++){
  80:main.c        **** 		sum = sum + pulseValue[i];
  81:main.c        **** 	}
  82:main.c        **** 	
  83:main.c        **** 	avgPulseValue = sum/values;
 210               	.LM16:
 211 009c 84E6      		ldi r24,lo8(100)
 212 009e 482E      		mov r4,r24
 213 00a0 512C      		mov r5,__zero_reg__
 214 00a2 612C      		mov r6,__zero_reg__
 215 00a4 712C      		mov r7,__zero_reg__
  84:main.c        **** 	
  85:main.c        ****     char pulseString[15];
  86:main.c        ****     sprintf(pulseString, "%d", avgPulseValue);
 217               	.LM17:
 218 00a6 90E0      		ldi r25,lo8(.LC0)
 219 00a8 C92E      		mov r12,r25
 220 00aa 90E0      		ldi r25,hi8(.LC0)
 221 00ac D92E      		mov r13,r25
 222 00ae 8E01      		movw r16,r28
 223 00b0 0753      		subi r16,55
 224 00b2 1F4F      		sbci r17,-1
 225               	.L6:
  67:main.c        ****     ADCSRA |= (1 << ADSC);                     // start ADC conversion
 227               	.LM18:
 228 00b4 8091 7A00 		lds r24,122
 229 00b8 8064      		ori r24,lo8(64)
 230 00ba 8093 7A00 		sts 122,r24
 231               	.L3:
  68:main.c        ****     loop_until_bit_is_clear(ADCSRA, ADSC);     // wait until done
 233               	.LM19:
 234 00be 8091 7A00 		lds r24,122
 235 00c2 86FD      		sbrc r24,6
 236 00c4 00C0      		rjmp .L3
  70:main.c        ****     adcValue = ADC;
 238               	.LM20:
 239 00c6 6091 7800 		lds r22,120
 240 00ca 7091 7900 		lds r23,120+1
  71:main.c        ****     converter = adcValue*1.955;
 242               	.LM21:
 243 00ce 80E0      		ldi r24,0
 244 00d0 90E0      		ldi r25,0
 245 00d2 0E94 0000 		call __floatunsisf
 246 00d6 21E7      		ldi r18,lo8(113)
 247 00d8 3DE3      		ldi r19,lo8(61)
 248 00da 4AEF      		ldi r20,lo8(-6)
 249 00dc 5FE3      		ldi r21,lo8(63)
 250 00de 0E94 0000 		call __mulsf3
 251 00e2 FE01      		movw r30,r28
 252 00e4 E953      		subi r30,57
 253 00e6 FF4F      		sbci r31,-1
 254               	.L4:
  74:main.c        **** 		pulseValue[i] = pulseValue[i-1];
 256               	.LM22:
 257 00e8 3291      		ld r19,-Z
 258 00ea 2291      		ld r18,-Z
 259 00ec 3383      		std Z+3,r19
 260 00ee 2283      		std Z+2,r18
  73:main.c        ****     for(i=values-1;i>0;i--){
 262               	.LM23:
 263 00f0 EE15      		cp r30,r14
 264 00f2 FF05      		cpc r31,r15
 265 00f4 01F4      		brne .L4
  76:main.c        **** 	pulseValue[0] = converter + 500;
 267               	.LM24:
 268 00f6 20E0      		ldi r18,0
 269 00f8 30E0      		ldi r19,0
 270 00fa 4AEF      		ldi r20,lo8(-6)
 271 00fc 53E4      		ldi r21,lo8(67)
 272 00fe 0E94 0000 		call __addsf3
 273 0102 0E94 0000 		call __fixunssfsi
 274 0106 7A83      		std Y+2,r23
 275 0108 6983      		std Y+1,r22
 276 010a F701      		movw r30,r14
  78:main.c        ****     sum = 0;
 278               	.LM25:
 279 010c 60E0      		ldi r22,0
 280 010e 70E0      		ldi r23,0
 281 0110 CB01      		movw r24,r22
 282               	.L5:
  80:main.c        **** 		sum = sum + pulseValue[i];
 284               	.LM26:
 285 0112 2191      		ld r18,Z+
 286 0114 3191      		ld r19,Z+
 287 0116 620F      		add r22,r18
 288 0118 731F      		adc r23,r19
 289 011a 811D      		adc r24,__zero_reg__
 290 011c 911D      		adc r25,__zero_reg__
  79:main.c        ****     for(i=0;i<values;i++){
 292               	.LM27:
 293 011e EA15      		cp r30,r10
 294 0120 FB05      		cpc r31,r11
 295 0122 01F4      		brne .L5
  83:main.c        **** 	avgPulseValue = sum/values;
 297               	.LM28:
 298 0124 A301      		movw r20,r6
 299 0126 9201      		movw r18,r4
 300 0128 0E94 0000 		call __udivmodsi4
 301 012c C901      		movw r24,r18
 303               	.LM29:
 304 012e 9F93      		push r25
 305 0130 2F93      		push r18
 306 0132 DF92      		push r13
 307 0134 CF92      		push r12
 308 0136 1F93      		push r17
 309 0138 0F93      		push r16
 310 013a C852      		subi r28,lo8(-216)
 311 013c DF4F      		sbci r29,hi8(-216)
 312 013e 2883      		st Y,r18
 313 0140 C85D      		subi r28,lo8(216)
 314 0142 D040      		sbci r29,hi8(216)
 315 0144 C752      		subi r28,lo8(-217)
 316 0146 DF4F      		sbci r29,hi8(-217)
 317 0148 3883      		st Y,r19
 318 014a C95D      		subi r28,lo8(217)
 319 014c D040      		sbci r29,hi8(217)
 320 014e C652      		subi r28,lo8(-218)
 321 0150 DF4F      		sbci r29,hi8(-218)
 322 0152 4883      		st Y,r20
 323 0154 CA5D      		subi r28,lo8(218)
 324 0156 D040      		sbci r29,hi8(218)
 325 0158 C552      		subi r28,lo8(-219)
 326 015a DF4F      		sbci r29,hi8(-219)
 327 015c 5883      		st Y,r21
 328 015e CB5D      		subi r28,lo8(219)
 329 0160 D040      		sbci r29,hi8(219)
 330 0162 0E94 0000 		call sprintf
  87:main.c        ****     
  88:main.c        ****     printString(pulseString);
 332               	.LM30:
 333 0166 C801      		movw r24,r16
 334 0168 0E94 0000 		call printString
  89:main.c        ****     printString("\r\n");
 336               	.LM31:
 337 016c 80E0      		ldi r24,lo8(.LC1)
 338 016e 90E0      		ldi r25,hi8(.LC1)
 339 0170 0E94 0000 		call printString
  90:main.c        ****     
  91:main.c        ****     OCR1A = avgPulseValue;
 341               	.LM32:
 342 0174 C852      		subi r28,lo8(-216)
 343 0176 DF4F      		sbci r29,hi8(-216)
 344 0178 2881      		ld r18,Y
 345 017a C85D      		subi r28,lo8(216)
 346 017c D040      		sbci r29,hi8(216)
 347 017e C752      		subi r28,lo8(-217)
 348 0180 DF4F      		sbci r29,hi8(-217)
 349 0182 3881      		ld r19,Y
 350 0184 C95D      		subi r28,lo8(217)
 351 0186 D040      		sbci r29,hi8(217)
 352 0188 3093 8900 		sts 136+1,r19
 353 018c 2093 8800 		sts 136,r18
 354               	.LBE11:
  92:main.c        ****     //_delay_ms(50);
  93:main.c        ****     
  94:main.c        ****  }
 356               	.LM33:
 357 0190 0F90      		pop __tmp_reg__
 358 0192 0F90      		pop __tmp_reg__
 359 0194 0F90      		pop __tmp_reg__
 360 0196 0F90      		pop __tmp_reg__
 361 0198 0F90      		pop __tmp_reg__
 362 019a 0F90      		pop __tmp_reg__
 363 019c 00C0      		rjmp .L6
 372               	.Lscope1:
 374               		.stabd	78,0,0
 375               		.text
 377               	.Letext0:
 378               		.ident	"GCC: (GNU) 4.7.2"
 379               	.global __do_copy_data
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccuVM0nk.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccuVM0nk.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccuVM0nk.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccuVM0nk.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccuVM0nk.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccuVM0nk.s:101    .text.startup:0000000000000000 main

UNDEFINED SYMBOLS
__floatunsisf
__mulsf3
__addsf3
__fixunssfsi
initUSART
__udivmodsi4
sprintf
printString
__do_copy_data
