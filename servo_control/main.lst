   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 121               	.global	PCINT1_vect
 123               	PCINT1_vect:
 124               		.stabd	46,0,0
   1:main.c        **** /* Temple Relief Robot, ASME Design Competition 2015
   2:main.c        ****  * -------------------------------------------------
   3:main.c        ****  * Title: temple-relief-robot/src/main.c
   4:main.c        ****  * 
   5:main.c        ****  * Description: 
   6:main.c        ****  * code to implement position control onto customized motor controller
   7:main.c        ****  * 04/04/2015
   8:main.c        ****  * 
   9:main.c        ****  * Written by: Christian D. Valenti (christian.valenti@temple.edu)
  10:main.c        ****  * 
  11:main.c        ****  */
  12:main.c        **** 
  13:main.c        **** #define MCU 'attiny85'
  14:main.c        **** #define F_CPU 1000000UL
  15:main.c        **** 
  16:main.c        **** #include <avr/io.h>
  17:main.c        **** #include <avr/interrupt.h>
  18:main.c        **** #include "include/easy_attiny85.h"
  19:main.c        **** #include "include/pinDefines.h"
  20:main.c        **** #include <stdio.h>
  21:main.c        **** #include <stdlib.h>
  22:main.c        **** 
  23:main.c        **** 
  24:main.c        **** //new pin defines
  25:main.c        **** #define ADC_IN       PB4
  26:main.c        **** #define ADC_CHANNEL  2
  27:main.c        **** #define DRIVER_PWM   PB0
  28:main.c        **** #define DRIVER_A     PB5
  29:main.c        **** #define DRIVER_B     PB3
  30:main.c        **** #define ENCODER_A    PB1
  31:main.c        **** #define ENCODER_B    PB2
  32:main.c        **** 
  33:main.c        **** /* PLAN FOR CODE:
  34:main.c        ****  * 
  35:main.c        ****  *    Read ADC (input signal) and send to moving average -> translate to a desired encoder position
  36:main.c        ****  *    Implement ISR to update encoder count variable
  37:main.c        ****  *    Compare output encoder var to desired encoder position (ERROR)
  38:main.c        ****  *    translate error to a duty % and direction
  39:main.c        ****  *    set A and B (directionals) and duty (PWM)
  40:main.c        ****  *    repeat
  41:main.c        ****  */
  42:main.c        **** 
  43:main.c        **** //declare volatile global variable that can be accessed by both the ISRs and main
  44:main.c        **** volatile long encoder_count;
  45:main.c        **** 
  46:main.c        **** //function declarations
  47:main.c        **** void initADC(void);
  48:main.c        **** uint16_t readADC(uint8_t channel);
  49:main.c        **** void initValues(uint16_t * arr, uint8_t size, uint16_t value);
  50:main.c        **** void storeNewADC(uint16_t * arr, uint8_t size, uint8_t channel);
  51:main.c        **** uint16_t getAverage(uint16_t * arr, uint8_t size);
  52:main.c        **** void initMotorDriverIO(void);
  53:main.c        **** void initTimer0PWM(void);
  54:main.c        **** void initPCInterrupts(void);
  55:main.c        **** 
  56:main.c        **** ISR(PCINT1_vect) {
 126               	.LM0:
 127               	.LFBB1:
 128 0000 1F92      		push r1
 129 0002 0F92      		push r0
 130 0004 0FB6      		in r0,__SREG__
 131 0006 0F92      		push r0
 132 0008 1124      		clr __zero_reg__
 133 000a 8F93      		push r24
 134 000c 9F93      		push r25
 135 000e AF93      		push r26
 136 0010 BF93      		push r27
 137               	/* prologue: Signal */
 138               	/* frame size = 0 */
 139               	/* stack size = 7 */
 140               	.L__stack_usage = 7
  57:main.c        ****   
  58:main.c        ****   if(bit_is_set(PINB, ENCODER_A)){
 142               	.LM1:
 143 0012 B19B      		sbis 0x16,1
 144 0014 00C0      		rjmp .L2
  59:main.c        ****     if(bit_is_set(PINB, ENCODER_B)){
 146               	.LM2:
 147 0016 B29B      		sbis 0x16,2
 148 0018 00C0      		rjmp .L7
 149 001a 00C0      		rjmp .L5
 150               	.L2:
  60:main.c        ****       encoder_count--;
  61:main.c        ****     }else{
  62:main.c        ****       encoder_count++;
  63:main.c        ****     }
  64:main.c        ****   }else{
  65:main.c        ****     if(bit_is_set(PINB, ENCODER_B)){
 152               	.LM3:
 153 001c B29B      		sbis 0x16,2
 154 001e 00C0      		rjmp .L5
 155               	.L7:
  66:main.c        ****       encoder_count++;
 157               	.LM4:
 158 0020 8091 0000 		lds r24,encoder_count
 159 0024 9091 0000 		lds r25,encoder_count+1
 160 0028 A091 0000 		lds r26,encoder_count+2
 161 002c B091 0000 		lds r27,encoder_count+3
 162 0030 0196      		adiw r24,1
 163 0032 A11D      		adc r26,__zero_reg__
 164 0034 B11D      		adc r27,__zero_reg__
 165 0036 00C0      		rjmp .L6
 166               	.L5:
  67:main.c        ****     }else{
  68:main.c        ****       encoder_count--;
 168               	.LM5:
 169 0038 8091 0000 		lds r24,encoder_count
 170 003c 9091 0000 		lds r25,encoder_count+1
 171 0040 A091 0000 		lds r26,encoder_count+2
 172 0044 B091 0000 		lds r27,encoder_count+3
 173 0048 0197      		sbiw r24,1
 174 004a A109      		sbc r26,__zero_reg__
 175 004c B109      		sbc r27,__zero_reg__
 176               	.L6:
 177 004e 8093 0000 		sts encoder_count,r24
 178 0052 9093 0000 		sts encoder_count+1,r25
 179 0056 A093 0000 		sts encoder_count+2,r26
 180 005a B093 0000 		sts encoder_count+3,r27
 181               	/* epilogue start */
  69:main.c        ****     }
  70:main.c        ****   }
  71:main.c        **** }
 183               	.LM6:
 184 005e BF91      		pop r27
 185 0060 AF91      		pop r26
 186 0062 9F91      		pop r25
 187 0064 8F91      		pop r24
 188 0066 0F90      		pop r0
 189 0068 0FBE      		out __SREG__,r0
 190 006a 0F90      		pop r0
 191 006c 1F90      		pop r1
 192 006e 1895      		reti
 194               	.Lscope1:
 196               		.stabd	78,0,0
 198               	.global	PCINT2_vect
 200               	PCINT2_vect:
 201               		.stabd	46,0,0
  72:main.c        **** 
  73:main.c        **** ISR(PCINT2_vect) {
 203               	.LM7:
 204               	.LFBB2:
 205 0070 1F92      		push r1
 206 0072 0F92      		push r0
 207 0074 0FB6      		in r0,__SREG__
 208 0076 0F92      		push r0
 209 0078 1124      		clr __zero_reg__
 210 007a 8F93      		push r24
 211 007c 9F93      		push r25
 212 007e AF93      		push r26
 213 0080 BF93      		push r27
 214               	/* prologue: Signal */
 215               	/* frame size = 0 */
 216               	/* stack size = 7 */
 217               	.L__stack_usage = 7
  74:main.c        ****  
  75:main.c        ****  if(bit_is_set(PINB, ENCODER_B)){
 219               	.LM8:
 220 0082 B29B      		sbis 0x16,2
 221 0084 00C0      		rjmp .L10
  76:main.c        ****     if(bit_is_set(PINB, ENCODER_A)){
 223               	.LM9:
 224 0086 B19B      		sbis 0x16,1
 225 0088 00C0      		rjmp .L15
 226 008a 00C0      		rjmp .L13
 227               	.L10:
  77:main.c        ****       encoder_count++;
  78:main.c        ****     }else{
  79:main.c        ****       encoder_count--;
  80:main.c        ****     }
  81:main.c        ****   }else{
  82:main.c        ****     if(bit_is_set(PINB, ENCODER_A)){
 229               	.LM10:
 230 008c B19B      		sbis 0x16,1
 231 008e 00C0      		rjmp .L13
 232               	.L15:
  83:main.c        ****       encoder_count--;
 234               	.LM11:
 235 0090 8091 0000 		lds r24,encoder_count
 236 0094 9091 0000 		lds r25,encoder_count+1
 237 0098 A091 0000 		lds r26,encoder_count+2
 238 009c B091 0000 		lds r27,encoder_count+3
 239 00a0 0197      		sbiw r24,1
 240 00a2 A109      		sbc r26,__zero_reg__
 241 00a4 B109      		sbc r27,__zero_reg__
 242 00a6 00C0      		rjmp .L14
 243               	.L13:
  84:main.c        ****     }else{
  85:main.c        ****       encoder_count++;
 245               	.LM12:
 246 00a8 8091 0000 		lds r24,encoder_count
 247 00ac 9091 0000 		lds r25,encoder_count+1
 248 00b0 A091 0000 		lds r26,encoder_count+2
 249 00b4 B091 0000 		lds r27,encoder_count+3
 250 00b8 0196      		adiw r24,1
 251 00ba A11D      		adc r26,__zero_reg__
 252 00bc B11D      		adc r27,__zero_reg__
 253               	.L14:
 254 00be 8093 0000 		sts encoder_count,r24
 255 00c2 9093 0000 		sts encoder_count+1,r25
 256 00c6 A093 0000 		sts encoder_count+2,r26
 257 00ca B093 0000 		sts encoder_count+3,r27
 258               	/* epilogue start */
  86:main.c        ****     }
  87:main.c        ****   }
  88:main.c        **** }
 260               	.LM13:
 261 00ce BF91      		pop r27
 262 00d0 AF91      		pop r26
 263 00d2 9F91      		pop r25
 264 00d4 8F91      		pop r24
 265 00d6 0F90      		pop r0
 266 00d8 0FBE      		out __SREG__,r0
 267 00da 0F90      		pop r0
 268 00dc 1F90      		pop r1
 269 00de 1895      		reti
 271               	.Lscope2:
 273               		.stabd	78,0,0
 275               	.global	initADC
 277               	initADC:
 278               		.stabd	46,0,0
  89:main.c        **** 
  90:main.c        **** int main(void) {
  91:main.c        ****   
  92:main.c        ****   //initialize functions (ADC, PWM, I/O)
  93:main.c        ****   initADC();
  94:main.c        ****   initMotorDriverIO();
  95:main.c        ****   initTimer0PWM();
  96:main.c        ****   initPCInterrupts();
  97:main.c        ****   
  98:main.c        ****   //gearmotor characteristics
  99:main.c        ****   int cpr = 8400;
 100:main.c        ****   float chain_ratio = 16*(12/9);
 101:main.c        ****   int range_of_motion = 180;
 102:main.c        ****   long max_desired_count = (cpr*chain_ratio)*(range_of_motion/360);
 103:main.c        ****   float ADC_multiplier = max_desired_count/1023;
 104:main.c        ****   int slowdown_count = 2100;
 105:main.c        ****   int target_buffer = 250;
 106:main.c        ****   
 107:main.c        ****   //set up moving average array and init values to zero
 108:main.c        ****   uint8_t arraySize = 32;
 109:main.c        ****   uint16_t ADC_values [arraySize];
 110:main.c        ****   uint16_t * ADC_pointer;
 111:main.c        ****   ADC_pointer = &ADC_values[0];
 112:main.c        ****   initValues(ADC_pointer, arraySize, 0);
 113:main.c        ****   
 114:main.c        ****   //avg value variable
 115:main.c        ****   int ADC_avg;
 116:main.c        ****   
 117:main.c        ****   //positon variables
 118:main.c        ****   long desired_count;
 119:main.c        ****   long count_error;
 120:main.c        ****   
 121:main.c        ****   //local variable for current encoder count
 122:main.c        ****   long local_encoder_count;
 123:main.c        ****   
 124:main.c        ****   while(1) { 
 125:main.c        ****     
 126:main.c        ****     // Read ADC
 127:main.c        ****     storeNewADC(ADC_pointer, arraySize, ADC_CHANNEL);
 128:main.c        ****     ADC_avg = getAverage(ADC_pointer, arraySize);
 129:main.c        **** 
 130:main.c        ****     // Convert ADC to desired encoder count
 131:main.c        ****     desired_count = ADC_avg * ADC_multiplier;
 132:main.c        ****     
 133:main.c        ****     //update local variable
 134:main.c        ****     cli();
 135:main.c        ****     local_encoder_count = encoder_count;
 136:main.c        ****     sei();
 137:main.c        ****     
 138:main.c        ****     // Compare desired count to actual count
 139:main.c        ****     count_error = desired_count - local_encoder_count;
 140:main.c        ****     
 141:main.c        ****     // Translate error to a PWM duty: not within 90 degrees, go 100, otherwise scale down
 142:main.c        ****     // think direction and duty first?
 143:main.c        ****     if(count_error > slowdown_count){
 144:main.c        ****       OCR0A = 255;
 145:main.c        ****       pin_hi('B', DRIVER_A);
 146:main.c        ****       pin_lo('B', DRIVER_B);
 147:main.c        ****     }else if(count_error<=slowdown_count && count_error>target_buffer){
 148:main.c        ****       OCR0A = 255 * (count_error/slowdown_count);
 149:main.c        ****       pin_hi('B', DRIVER_A);
 150:main.c        ****       pin_lo('B', DRIVER_B);
 151:main.c        ****     }else if(count_error<=target_buffer && count_error>=-target_buffer){
 152:main.c        ****       OCR0A = 0;
 153:main.c        ****       pin_hi('B', DRIVER_A);
 154:main.c        ****       pin_lo('B', DRIVER_B);
 155:main.c        ****     }else if(count_error<-target_buffer && count_error>=-slowdown_count){
 156:main.c        ****       OCR0A = 255 * -(count_error/slowdown_count);
 157:main.c        ****       pin_hi('B', DRIVER_B);
 158:main.c        ****       pin_lo('B', DRIVER_A);
 159:main.c        ****     }else if(count_error < -slowdown_count){
 160:main.c        ****       OCR0A = 255;
 161:main.c        ****       pin_hi('B', DRIVER_B);
 162:main.c        ****       pin_lo('B', DRIVER_A);
 163:main.c        ****     }
 164:main.c        ****  }
 165:main.c        ****  
 166:main.c        ****  return(0);
 167:main.c        ****  
 168:main.c        **** }
 169:main.c        **** 
 170:main.c        **** void initADC(void) {
 280               	.LM14:
 281               	.LFBB3:
 282               	/* prologue: function */
 283               	/* frame size = 0 */
 284               	/* stack size = 0 */
 285               	.L__stack_usage = 0
 171:main.c        ****   //initialize ADC (set ref voltage, prescaler, and enable)
 172:main.c        ****   //updated for attiny85  
 173:main.c        ****   ADMUX &= ~(1 << REFS1);
 287               	.LM15:
 288 00e0 3F98      		cbi 0x7,7
 174:main.c        ****   ADMUX &= ~(1 << REFS0);
 290               	.LM16:
 291 00e2 3E98      		cbi 0x7,6
 175:main.c        ****   ADCSRA |= (1 << ADPS0) | (1 << ADPS1);    // ADC clock prescaler /8
 293               	.LM17:
 294 00e4 86B1      		in r24,0x6
 295 00e6 8360      		ori r24,lo8(3)
 296 00e8 86B9      		out 0x6,r24
 176:main.c        ****   ADCSRA |= (1 << ADEN);               			// enable ADC
 298               	.LM18:
 299 00ea 379A      		sbi 0x6,7
 300 00ec 0895      		ret
 302               	.Lscope3:
 304               		.stabd	78,0,0
 307               	.global	readADC
 309               	readADC:
 310               		.stabd	46,0,0
 177:main.c        **** }
 178:main.c        **** 
 179:main.c        **** uint16_t readADC(uint8_t channel) {
 312               	.LM19:
 313               	.LFBB4:
 314               	/* prologue: function */
 315               	/* frame size = 0 */
 316               	/* stack size = 0 */
 317               	.L__stack_usage = 0
 180:main.c        ****   //read ADC value from channel (ADC0 to ADC 5)
 181:main.c        ****   //works for attiny85
 182:main.c        ****   ADMUX = (0b11110000 & ADMUX) | channel;
 319               	.LM20:
 320 00ee 97B1      		in r25,0x7
 321 00f0 907F      		andi r25,lo8(-16)
 322 00f2 982B      		or r25,r24
 323 00f4 97B9      		out 0x7,r25
 183:main.c        ****   ADCSRA |= (1 << ADSC);
 325               	.LM21:
 326 00f6 369A      		sbi 0x6,6
 327               	.L19:
 184:main.c        ****   loop_until_bit_is_clear(ADCSRA, ADSC);
 329               	.LM22:
 330 00f8 3699      		sbic 0x6,6
 331 00fa 00C0      		rjmp .L19
 185:main.c        ****   return (ADC);
 333               	.LM23:
 334 00fc 84B1      		in r24,0x4
 335 00fe 95B1      		in r25,0x4+1
 186:main.c        **** }
 337               	.LM24:
 338 0100 0895      		ret
 340               	.Lscope4:
 342               		.stabd	78,0,0
 347               	.global	initValues
 349               	initValues:
 350               		.stabd	46,0,0
 187:main.c        **** 
 188:main.c        **** void initValues(uint16_t * arr, uint8_t size, uint16_t value){
 352               	.LM25:
 353               	.LFBB5:
 354               	/* prologue: function */
 355               	/* frame size = 0 */
 356               	/* stack size = 0 */
 357               	.L__stack_usage = 0
 189:main.c        ****   
 190:main.c        ****   uint8_t i;
 191:main.c        ****   
 192:main.c        ****   //copy 'value' into each element of array
 193:main.c        ****   for(i=0;i<size;i++){
 359               	.LM26:
 360 0102 20E0      		ldi r18,0
 361               	.L21:
 363               	.LM27:
 364 0104 2617      		cp r18,r22
 365 0106 01F0      		breq .L23
 194:main.c        ****      *arr = value;
 367               	.LM28:
 368 0108 FC01      		movw r30,r24
 369 010a 4193      		st Z+,r20
 370 010c 5193      		st Z+,r21
 371 010e CF01      		movw r24,r30
 193:main.c        ****   for(i=0;i<size;i++){
 373               	.LM29:
 374 0110 2F5F      		subi r18,lo8(-(1))
 375 0112 00C0      		rjmp .L21
 376               	.L23:
 377               	/* epilogue start */
 195:main.c        ****      arr++;
 196:main.c        ****   }
 197:main.c        **** }
 379               	.LM30:
 380 0114 0895      		ret
 385               	.Lscope5:
 387               		.stabd	78,0,0
 392               	.global	storeNewADC
 394               	storeNewADC:
 395               		.stabd	46,0,0
 198:main.c        **** 
 199:main.c        **** void storeNewADC(uint16_t * arr, uint8_t size, uint8_t channel){
 397               	.LM31:
 398               	.LFBB6:
 399 0116 CF93      		push r28
 400 0118 DF93      		push r29
 401               	/* prologue: function */
 402               	/* frame size = 0 */
 403               	/* stack size = 2 */
 404               	.L__stack_usage = 2
 200:main.c        ****   
 201:main.c        ****   uint8_t i;
 202:main.c        ****   arr = arr + (size-1);
 406               	.LM32:
 407 011a 70E0      		ldi r23,0
 408 011c EB01      		movw r28,r22
 409 011e C150      		subi r28,1
 410 0120 D048      		sbci r29,-128
 411 0122 CC0F      		lsl r28
 412 0124 DD1F      		rol r29
 413 0126 C80F      		add r28,r24
 414 0128 D91F      		adc r29,r25
 203:main.c        ****   
 204:main.c        ****   //starting with last element of array, store value from the previous element
 205:main.c        ****   for (i=0;i<(size-1);i++){
 416               	.LM33:
 417 012a 90E0      		ldi r25,0
 418 012c 6150      		subi r22,1
 419 012e 7109      		sbc r23,__zero_reg__
 420               	.L25:
 422               	.LM34:
 423 0130 292F      		mov r18,r25
 424 0132 30E0      		ldi r19,0
 425 0134 2617      		cp r18,r22
 426 0136 3707      		cpc r19,r23
 427 0138 04F4      		brge .L27
 428 013a FE01      		movw r30,r28
 206:main.c        ****     *arr = *(arr-1);
 430               	.LM35:
 431 013c 3291      		ld r19,-Z
 432 013e 2291      		ld r18,-Z
 433 0140 3983      		std Y+1,r19
 434 0142 2883      		st Y,r18
 205:main.c        ****   for (i=0;i<(size-1);i++){
 436               	.LM36:
 437 0144 9F5F      		subi r25,lo8(-(1))
 207:main.c        ****     arr--;
 439               	.LM37:
 440 0146 EF01      		movw r28,r30
 441 0148 00C0      		rjmp .L25
 442               	.L27:
 208:main.c        ****   }
 209:main.c        ****   
 210:main.c        ****   //read ADC for newest value into array
 211:main.c        ****   *arr = readADC(channel);
 444               	.LM38:
 445 014a 842F      		mov r24,r20
 446 014c 00D0      		rcall readADC
 447 014e 9983      		std Y+1,r25
 448 0150 8883      		st Y,r24
 449               	/* epilogue start */
 212:main.c        **** }
 451               	.LM39:
 452 0152 DF91      		pop r29
 453 0154 CF91      		pop r28
 454 0156 0895      		ret
 459               	.Lscope6:
 461               		.stabd	78,0,0
 465               	.global	getAverage
 467               	getAverage:
 468               		.stabd	46,0,0
 213:main.c        **** 
 214:main.c        **** uint16_t getAverage(uint16_t * arr, uint8_t size){
 470               	.LM40:
 471               	.LFBB7:
 472               	/* prologue: function */
 473               	/* frame size = 0 */
 474               	/* stack size = 0 */
 475               	.L__stack_usage = 0
 476 0158 FC01      		movw r30,r24
 477 015a 362F      		mov r19,r22
 215:main.c        ****   
 216:main.c        ****   uint8_t i;
 217:main.c        ****   uint16_t avg;
 218:main.c        ****   uint32_t sum = 0;
 479               	.LM41:
 480 015c 60E0      		ldi r22,0
 481 015e 70E0      		ldi r23,0
 482 0160 CB01      		movw r24,r22
 219:main.c        ****       
 220:main.c        ****   //sum all elements in array
 221:main.c        ****   for(i=0;i<size;i++){
 484               	.LM42:
 485 0162 20E0      		ldi r18,0
 486               	.L29:
 488               	.LM43:
 489 0164 2317      		cp r18,r19
 490 0166 01F0      		breq .L31
 222:main.c        ****     sum = sum + *arr;
 492               	.LM44:
 493 0168 4191      		ld r20,Z+
 494 016a 5191      		ld r21,Z+
 495 016c 640F      		add r22,r20
 496 016e 751F      		adc r23,r21
 497 0170 811D      		adc r24,__zero_reg__
 498 0172 911D      		adc r25,__zero_reg__
 221:main.c        ****   for(i=0;i<size;i++){
 500               	.LM45:
 501 0174 2F5F      		subi r18,lo8(-(1))
 502 0176 00C0      		rjmp .L29
 503               	.L31:
 223:main.c        ****     arr++;
 224:main.c        ****   }
 225:main.c        ****   
 226:main.c        ****   //calculate avg and return 
 227:main.c        ****   avg = sum / size;
 505               	.LM46:
 506 0178 30E0      		ldi r19,0
 507 017a 40E0      		ldi r20,0
 508 017c 50E0      		ldi r21,0
 509 017e 00D0      		rcall __udivmodsi4
 228:main.c        ****   return avg;
 229:main.c        **** }
 511               	.LM47:
 512 0180 C901      		movw r24,r18
 513 0182 0895      		ret
 519               	.Lscope7:
 521               		.stabd	78,0,0
 523               	.global	initTimer0PWM
 525               	initTimer0PWM:
 526               		.stabd	46,0,0
 230:main.c        **** 
 231:main.c        **** //removed Timer1 setup
 232:main.c        **** 
 233:main.c        **** void initTimer0PWM(void){
 528               	.LM48:
 529               	.LFBB8:
 530               	/* prologue: function */
 531               	/* frame size = 0 */
 532               	/* stack size = 0 */
 533               	.L__stack_usage = 0
 234:main.c        ****   /* Set up Timer0 (8bit) */
 235:main.c        ****   //changed for attiny85
 236:main.c        ****   //Use Mode 3, FastPWM
 237:main.c        ****   TCCR0A |= (1 << WGM00) | (1 << WGM01);
 535               	.LM49:
 536 0184 8AB5      		in r24,0x2a
 537 0186 8360      		ori r24,lo8(3)
 538 0188 8ABD      		out 0x2a,r24
 238:main.c        **** 
 239:main.c        ****   //Clear at match, set at bottom
 240:main.c        ****   TCCR0A |= (1 << COM0A1);
 540               	.LM50:
 541 018a 8AB5      		in r24,0x2a
 542 018c 8068      		ori r24,lo8(-128)
 543 018e 8ABD      		out 0x2a,r24
 241:main.c        ****   
 242:main.c        ****   // No prescale, gives freq = ~4kHz
 243:main.c        ****   TCCR0B |= (1<<CS00);
 545               	.LM51:
 546 0190 83B7      		in r24,0x33
 547 0192 8160      		ori r24,lo8(1)
 548 0194 83BF      		out 0x33,r24
 244:main.c        ****   
 245:main.c        ****   //set pins for output
 246:main.c        ****   DDRB |= (1 << DRIVER_PWM);
 550               	.LM52:
 551 0196 B89A      		sbi 0x17,0
 552 0198 0895      		ret
 554               	.Lscope8:
 556               		.stabd	78,0,0
 558               	.global	initMotorDriverIO
 560               	initMotorDriverIO:
 561               		.stabd	46,0,0
 247:main.c        **** }
 248:main.c        **** 
 249:main.c        **** void initMotorDriverIO(void){
 563               	.LM53:
 564               	.LFBB9:
 565               	/* prologue: function */
 566               	/* frame size = 0 */
 567               	/* stack size = 0 */
 568               	.L__stack_usage = 0
 250:main.c        ****   //set for output
 251:main.c        ****   DDRB |= (1<<DRIVER_A);
 570               	.LM54:
 571 019a BD9A      		sbi 0x17,5
 252:main.c        ****   DDRB |= (1<<DRIVER_B);
 573               	.LM55:
 574 019c BB9A      		sbi 0x17,3
 253:main.c        ****   //init to zero
 254:main.c        ****   pin_lo('B',DRIVER_A);
 576               	.LM56:
 577 019e 65E0      		ldi r22,lo8(5)
 578 01a0 70E0      		ldi r23,0
 579 01a2 82E4      		ldi r24,lo8(66)
 580 01a4 90E0      		ldi r25,0
 581 01a6 00D0      		rcall pin_lo
 255:main.c        ****   pin_lo('B',DRIVER_B);
 583               	.LM57:
 584 01a8 63E0      		ldi r22,lo8(3)
 585 01aa 70E0      		ldi r23,0
 586 01ac 82E4      		ldi r24,lo8(66)
 587 01ae 90E0      		ldi r25,0
 588 01b0 00C0      		rjmp pin_lo
 590               	.Lscope9:
 592               		.stabd	78,0,0
 594               	.global	initPCInterrupts
 596               	initPCInterrupts:
 597               		.stabd	46,0,0
 256:main.c        **** 
 257:main.c        **** }
 258:main.c        **** //removed motor calculations
 259:main.c        **** 
 260:main.c        **** void initPCInterrupts(void){
 599               	.LM58:
 600               	.LFBB10:
 601               	/* prologue: function */
 602               	/* frame size = 0 */
 603               	/* stack size = 0 */
 604               	.L__stack_usage = 0
 261:main.c        ****   DDRB &= ~(1<<ENCODER_A);
 606               	.LM59:
 607 01b2 B998      		cbi 0x17,1
 262:main.c        ****   DDRB &= ~(1<<ENCODER_B);
 609               	.LM60:
 610 01b4 BA98      		cbi 0x17,2
 263:main.c        ****   PORTB |= (1<<ENCODER_A);
 612               	.LM61:
 613 01b6 C19A      		sbi 0x18,1
 264:main.c        ****   PORTB |= (1<<ENCODER_B);
 615               	.LM62:
 616 01b8 C29A      		sbi 0x18,2
 265:main.c        ****   GIMSK |= (1<<PCIE);
 618               	.LM63:
 619 01ba 8BB7      		in r24,0x3b
 620 01bc 8062      		ori r24,lo8(32)
 621 01be 8BBF      		out 0x3b,r24
 266:main.c        ****   PCMSK |= (1<<PCINT1) | (1<<PCINT2);
 623               	.LM64:
 624 01c0 85B3      		in r24,0x15
 625 01c2 8660      		ori r24,lo8(6)
 626 01c4 85BB      		out 0x15,r24
 267:main.c        ****   sei();
 628               	.LM65:
 629               	/* #APP */
 630               	 ;  267 "main.c" 1
 631 01c6 7894      		sei
 632               	 ;  0 "" 2
 633               	/* #NOAPP */
 634 01c8 0895      		ret
 636               	.Lscope10:
 638               		.stabd	78,0,0
 639               	.global	__floatsisf
 640               	.global	__mulsf3
 641               	.global	__fixsfsi
 642               		.section	.text.startup,"ax",@progbits
 644               	.global	main
 646               	main:
 647               		.stabd	46,0,0
  90:main.c        **** int main(void) {
 649               	.LM66:
 650               	.LFBB11:
 651 0000 CF93      		push r28
 652 0002 DF93      		push r29
 653 0004 CDB7      		in r28,__SP_L__
 654 0006 DEB7      		in r29,__SP_H__
 655 0008 C054      		subi r28,64
 656 000a D109      		sbc r29,__zero_reg__
 657 000c 0FB6      		in __tmp_reg__,__SREG__
 658 000e F894      		cli
 659 0010 DEBF      		out __SP_H__,r29
 660 0012 0FBE      		out __SREG__,__tmp_reg__
 661 0014 CDBF      		out __SP_L__,r28
 662               	/* prologue: function */
 663               	/* frame size = 64 */
 664               	/* stack size = 66 */
 665               	.L__stack_usage = 66
  93:main.c        ****   initADC();
 667               	.LM67:
 668 0016 00D0      		rcall initADC
  94:main.c        ****   initMotorDriverIO();
 670               	.LM68:
 671 0018 00D0      		rcall initMotorDriverIO
  95:main.c        ****   initTimer0PWM();
 673               	.LM69:
 674 001a 00D0      		rcall initTimer0PWM
  96:main.c        ****   initPCInterrupts();
 676               	.LM70:
 677 001c 00D0      		rcall initPCInterrupts
 112:main.c        ****   initValues(ADC_pointer, arraySize, 0);
 679               	.LM71:
 680 001e 40E0      		ldi r20,0
 681 0020 50E0      		ldi r21,0
 682 0022 60E2      		ldi r22,lo8(32)
 683 0024 CE01      		movw r24,r28
 684 0026 0196      		adiw r24,1
 685 0028 00D0      		rcall initValues
 686               	.LBB2:
 160:main.c        ****       OCR0A = 255;
 688               	.LM72:
 689 002a 1FEF      		ldi r17,lo8(-1)
 690               	.LBE2:
 691               	.LBB3:
 156:main.c        ****       OCR0A = 255 * -(count_error/slowdown_count);
 693               	.LM73:
 694 002c 34E3      		ldi r19,lo8(52)
 695 002e C32E      		mov r12,r19
 696 0030 38E0      		ldi r19,lo8(8)
 697 0032 D32E      		mov r13,r19
 698 0034 E12C      		mov r14,__zero_reg__
 699 0036 F12C      		mov r15,__zero_reg__
 700               	.L36:
 701               	.LBE3:
 127:main.c        ****     storeNewADC(ADC_pointer, arraySize, ADC_CHANNEL);
 703               	.LM74:
 704 0038 42E0      		ldi r20,lo8(2)
 705 003a 60E2      		ldi r22,lo8(32)
 706 003c CE01      		movw r24,r28
 707 003e 0196      		adiw r24,1
 708 0040 00D0      		rcall storeNewADC
 128:main.c        ****     ADC_avg = getAverage(ADC_pointer, arraySize);
 710               	.LM75:
 711 0042 60E2      		ldi r22,lo8(32)
 712 0044 CE01      		movw r24,r28
 713 0046 0196      		adiw r24,1
 714 0048 00D0      		rcall getAverage
 134:main.c        ****     cli();
 716               	.LM76:
 717               	/* #APP */
 718               	 ;  134 "main.c" 1
 719 004a F894      		cli
 720               	 ;  0 "" 2
 135:main.c        ****     local_encoder_count = encoder_count;
 722               	.LM77:
 723               	/* #NOAPP */
 724 004c 8090 0000 		lds r8,encoder_count
 725 0050 9090 0000 		lds r9,encoder_count+1
 726 0054 A090 0000 		lds r10,encoder_count+2
 727 0058 B090 0000 		lds r11,encoder_count+3
 136:main.c        ****     sei();
 729               	.LM78:
 730               	/* #APP */
 731               	 ;  136 "main.c" 1
 732 005c 7894      		sei
 733               	 ;  0 "" 2
 131:main.c        ****     desired_count = ADC_avg * ADC_multiplier;
 735               	.LM79:
 736               	/* #NOAPP */
 737 005e BC01      		movw r22,r24
 738 0060 8827      		clr r24
 739 0062 77FD      		sbrc r23,7
 740 0064 8095      		com r24
 741 0066 982F      		mov r25,r24
 742 0068 00D0      		rcall __floatsisf
 743 006a 20E0      		ldi r18,0
 744 006c 30E0      		ldi r19,0
 745 006e A901      		movw r20,r18
 746 0070 00D0      		rcall __mulsf3
 747 0072 00D0      		rcall __fixsfsi
 139:main.c        ****     count_error = desired_count - local_encoder_count;
 749               	.LM80:
 750 0074 6819      		sub r22,r8
 751 0076 7909      		sbc r23,r9
 752 0078 8A09      		sbc r24,r10
 753 007a 9B09      		sbc r25,r11
 143:main.c        ****     if(count_error > slowdown_count){
 755               	.LM81:
 756 007c 6533      		cpi r22,53
 757 007e 28E0      		ldi r18,8
 758 0080 7207      		cpc r23,r18
 759 0082 8105      		cpc r24,__zero_reg__
 760 0084 9105      		cpc r25,__zero_reg__
 761 0086 04F0      		brlt .L37
 762               	.LBB4:
 144:main.c        ****       OCR0A = 255;
 764               	.LM82:
 765 0088 19BD      		out 0x29,r17
 766 008a 00C0      		rjmp .L44
 767               	.L37:
 768               	.LBE4:
 147:main.c        ****     }else if(count_error<=slowdown_count && count_error>target_buffer){
 770               	.LM83:
 771 008c 6B3F      		cpi r22,-5
 772 008e 7105      		cpc r23,__zero_reg__
 773 0090 8105      		cpc r24,__zero_reg__
 774 0092 9105      		cpc r25,__zero_reg__
 775 0094 04F0      		brlt .L39
 776               	.LBB5:
 148:main.c        ****       OCR0A = 255 * (count_error/slowdown_count);
 778               	.LM84:
 779 0096 A701      		movw r20,r14
 780 0098 9601      		movw r18,r12
 781 009a 00D0      		rcall __divmodsi4
 782 009c 2195      		neg r18
 783 009e 29BD      		out 0x29,r18
 784 00a0 00C0      		rjmp .L44
 785               	.L39:
 786               	.LBE5:
 151:main.c        ****     }else if(count_error<=target_buffer && count_error>=-target_buffer){
 788               	.LM85:
 789 00a2 6630      		cpi r22,6
 790 00a4 2FEF      		ldi r18,-1
 791 00a6 7207      		cpc r23,r18
 792 00a8 8207      		cpc r24,r18
 793 00aa 9207      		cpc r25,r18
 794 00ac 04F0      		brlt .L40
 795               	.LBB6:
 152:main.c        ****       OCR0A = 0;
 797               	.LM86:
 798 00ae 19BC      		out 0x29,__zero_reg__
 799               	.L44:
 153:main.c        ****       pin_hi('B', DRIVER_A);
 801               	.LM87:
 802 00b0 65E0      		ldi r22,lo8(5)
 803 00b2 70E0      		ldi r23,0
 804 00b4 82E4      		ldi r24,lo8(66)
 805 00b6 90E0      		ldi r25,0
 806 00b8 00D0      		rcall pin_hi
 154:main.c        ****       pin_lo('B', DRIVER_B);
 808               	.LM88:
 809 00ba 63E0      		ldi r22,lo8(3)
 810 00bc 70E0      		ldi r23,0
 811 00be 00C0      		rjmp .L43
 812               	.L40:
 813               	.LBE6:
 155:main.c        ****     }else if(count_error<-target_buffer && count_error>=-slowdown_count){
 815               	.LM89:
 816 00c0 6C3C      		cpi r22,-52
 817 00c2 27EF      		ldi r18,-9
 818 00c4 7207      		cpc r23,r18
 819 00c6 2FEF      		ldi r18,-1
 820 00c8 8207      		cpc r24,r18
 821 00ca 9207      		cpc r25,r18
 822 00cc 04F0      		brlt .L41
 823               	.LBB7:
 156:main.c        ****       OCR0A = 255 * -(count_error/slowdown_count);
 825               	.LM90:
 826 00ce A701      		movw r20,r14
 827 00d0 9601      		movw r18,r12
 828 00d2 00D0      		rcall __divmodsi4
 829 00d4 29BD      		out 0x29,r18
 830 00d6 00C0      		rjmp .L42
 831               	.L41:
 832               	.LBE7:
 833               	.LBB8:
 160:main.c        ****       OCR0A = 255;
 835               	.LM91:
 836 00d8 19BD      		out 0x29,r17
 837               	.L42:
 161:main.c        ****       pin_hi('B', DRIVER_B);
 839               	.LM92:
 840 00da 63E0      		ldi r22,lo8(3)
 841 00dc 70E0      		ldi r23,0
 842 00de 82E4      		ldi r24,lo8(66)
 843 00e0 90E0      		ldi r25,0
 844 00e2 00D0      		rcall pin_hi
 162:main.c        ****       pin_lo('B', DRIVER_A);
 846               	.LM93:
 847 00e4 65E0      		ldi r22,lo8(5)
 848 00e6 70E0      		ldi r23,0
 849               	.L43:
 850 00e8 82E4      		ldi r24,lo8(66)
 851 00ea 90E0      		ldi r25,0
 852 00ec 00D0      		rcall pin_lo
 853 00ee 00C0      		rjmp .L36
 854               	.LBE8:
 860               	.Lscope11:
 862               		.stabd	78,0,0
 863               		.comm	encoder_count,4,1
 865               		.text
 867               	.Letext0:
 868               		.ident	"GCC: (GNU) 4.8.2"
 869               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccwom3mw.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccwom3mw.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccwom3mw.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccwom3mw.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccwom3mw.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccwom3mw.s:123    .text:0000000000000000 PCINT1_vect
                            *COM*:0000000000000004 encoder_count
     /tmp/ccwom3mw.s:200    .text:0000000000000070 PCINT2_vect
     /tmp/ccwom3mw.s:277    .text:00000000000000e0 initADC
     /tmp/ccwom3mw.s:309    .text:00000000000000ee readADC
     /tmp/ccwom3mw.s:349    .text:0000000000000102 initValues
     /tmp/ccwom3mw.s:394    .text:0000000000000116 storeNewADC
     /tmp/ccwom3mw.s:467    .text:0000000000000158 getAverage
     /tmp/ccwom3mw.s:525    .text:0000000000000184 initTimer0PWM
     /tmp/ccwom3mw.s:560    .text:000000000000019a initMotorDriverIO
     /tmp/ccwom3mw.s:596    .text:00000000000001b2 initPCInterrupts
     /tmp/ccwom3mw.s:646    .text.startup:0000000000000000 main

UNDEFINED SYMBOLS
__udivmodsi4
pin_lo
__floatsisf
__mulsf3
__fixsfsi
__divmodsi4
pin_hi
__do_clear_bss
